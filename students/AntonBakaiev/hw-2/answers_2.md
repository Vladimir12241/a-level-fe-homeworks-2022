typeof ('success' * 7) 
		NaN * 7
		NaN
//'number' // оператор * переобразует строку в число;

typeof (true + false) 
		1 + 0		
		1	
//'number'// true + false оператор + приводит к числам 1 + 0;

typeof (12 / '6') 
		12 / 6
			2
// 'number' // оператор деления приводит строку к числу;

typeof ('number' + 15 + 3) 
		'number15' + 3
		'number153'	
// 'string' // Оператор + выполнится слева на прваво по этому числа приведутся к строкам и дальше выполнится конкатенация дву строк;

typeof (15 + 3 + '')
		18 + 'number'
		'18number'
 // 'string' // сначало сумма двух чисел потом все авно переобразовывается ктипу строка и происходит конкатенация двух строк

typeof ([1] > null)
		'1' > 0
		1 > 0
		true
 // 'boolean' // оператор > приведет к численному значению 1 и 0 и условие выполнится тип будет boolean

typeof ('foo' + + 'bar') 
		'foo' + (+'bar')
		'foo' + NaN
		'fooNaN'
// 'string' // Унарный оператор + имеет более высокий приоритет чем бинарный оператор +. Поэтому выражение + 'bar' выполняется первым. Унарный плюс вызывает численное преобразования строки bar. Так как эта строка не представляет собой корректное число, результатом будет NaN. Следующим шагом выполнится выражение 'foo' + NaN

typeof ('' == true) 
		NaN == 1
		false
// 'boolean' // Оператор сравнения == вызывает численное преобразование, поэтому строка true конвертируется в NaN, а правый операнд true станет 1 по этому тип данных будет boolean;

typeof (false == '') 
		0 == NaN
		false
// 'boolean' // ситуация такая как и в предидущем примере

typeof (null == '') 
		false
// 'boolean' // действует исключение из правил: null равен только null или undefined и ничему другому 

typeof (!! 'false' == !! 'true') 
		true == true
		true
// 'boolean' // оператор !! конвертирует строки true и false в булевое значение true, так как это не пустые строки. А дальше оператор == просто сравнивает два булевых значения безо всяких преобразований

typeof (['x'] == 'x') 
		'x' == x
		true
// 'boolean' // Оператор == вызывает численное преобразование для массива. Метод массива valueOf() возвращает сам массив, а значит результат игнорируется, так как не является примитивом. Далее, вызывается метод массива toString(), который конвертирует [‘x’] в строку ‘x’

typeof !!{} // 'boolean' // то же самое что Boolean({})

typeof ![] 
		false
// 'boolean' // оператор ! НЕ переключает утверждение с истинного на ложное или с ложного на истинное.

typeof ([] + null + 1) 
		'' + null +1
		'null' + 1
		'null1'		
// 'string' // Оператор + вызывает численное преобразование массива. Метод массива valueOf() вернёт сам массив, поэтому результат игнорируется, поскольку не является примитивом, далее выполняется выражение ’’ + null + 1

typeof ([1, 2, 3] == [1, 2, 3]) 
		false
// 'boolean' // В данном примере никакого преобразования не требуется, потому что оба операнда одного типа. Так как оператор == сравнивает объекты по ссылке, а не по значению, а данные массивы являются двумя разными экземплярами, результатом будет false

typeof ({} + [] + {} +[1]) 
		+[]+{}+[1]
		0 + {} + [1]
		0 + '[object object]' + [1]
		'0[object object]' + [1]
		'0[object object]' + '1'
		'0[object object]1'
// 'string' // Все операнды являются не примитивами, поэтому + вызывает численное преобразование. Методы Object.valueOf() и Array.valueOf() возвращают самих себя, соответственно будут проигнорированы. В качестве запасного варианта, вызывается метод toString(). Трюк в том, что первый {} воспринимается движком не как создание объекта, а как объявление пустого блока кода и поэтому игнорируется. Выполнение начинается с выражения +[], которое преобразуется в пустую строку посредством метода toString(), и далее в 0

typeof (!+[] +[] +![]) 
		(!+[]) + [] +(![])
		!0 + [] + false 
		true + [] + false
		true + '' + false
		'truefalse'
// 'string' // схожая ситуация с выше преведенным примером

typeof(new Date(0) - 0) 
		0 - 0	
		0
// 'number' // Оператор - вызывает численное преобразование для объекта Date. Date.valueOf() возвращает количество миллисекунд прошедших с начала Unix эпохи (в данном случае 0)

typeof (new Date(0) + 0) 
		'Thu Jan 01 1970 02:00:00 GMT+0200 (EET)' + 0
		'Thu Jan 01 1970 02:00:00 GMT+0200 (EET)0'
// 'string' // Оператор + вызывает преобразование по умолчанию. Date, как исключение, подразумевает строковое преобразование, поэтому используется метод toString(), а не valueOf()

